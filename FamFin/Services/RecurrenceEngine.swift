import Foundation
import SwiftData

/// Processes recurring transactions, creating real Transaction records
/// for any occurrences that are due. Called on app launch to catch up
/// on any missed dates (e.g. if the app was not opened for several weeks).
enum RecurrenceEngine {

    /// Process all active recurring transactions, generating any due Transaction records.
    ///
    /// For each active RecurringTransaction whose nextOccurrence is on or before today:
    /// 1. Creates a Transaction from the template
    /// 2. Advances nextOccurrence to the next scheduled date
    /// 3. Repeats until nextOccurrence is in the future
    /// 4. Deactivates the recurring transaction if its endDate has been reached
    ///
    /// - Parameter context: The SwiftData model context to use for fetching and inserting.
    @MainActor
    static func processRecurringTransactions(context: ModelContext) {
        let descriptor = FetchDescriptor<RecurringTransaction>(
            predicate: #Predicate<RecurringTransaction> { $0.isActive }
        )
        guard let recurring = try? context.fetch(descriptor) else { return }

        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        var createdAny = false

        for rule in recurring {
            // Skip rules whose next occurrence is in the future
            var next = calendar.startOfDay(for: rule.nextOccurrence)
            guard next <= today else { continue }

            // Check if the rule has expired
            if let endDate = rule.endDate, next > calendar.startOfDay(for: endDate) {
                rule.isActive = false
                createdAny = true
                continue
            }

            // Generate transactions for each missed occurrence up to today
            while next <= today {
                // Check end date before generating
                if let endDate = rule.endDate, next > calendar.startOfDay(for: endDate) {
                    rule.isActive = false
                    break
                }

                createTransaction(from: rule, on: next, context: context)
                createdAny = true

                // Advance to next occurrence
                let advanced = rule.frequency.nextDate(after: next)
                rule.nextOccurrence = advanced
                next = calendar.startOfDay(for: advanced)

                // Check if the newly advanced date is past the end date
                if let endDate = rule.endDate, next > calendar.startOfDay(for: endDate) {
                    rule.isActive = false
                    break
                }
            }
        }

        if createdAny {
            try? context.save()
        }
    }

    /// Creates a single Transaction from a RecurringTransaction template on the given date.
    @MainActor
    private static func createTransaction(
        from rule: RecurringTransaction,
        on date: Date,
        context: ModelContext
    ) {
        let transaction = Transaction(
            amount: rule.amount,
            payee: rule.payee,
            memo: rule.memo,
            date: date,
            type: rule.type,
            isAutoGenerated: true
        )

        transaction.account = rule.account
        transaction.category = rule.category

        if rule.type == .transfer {
            transaction.transferToAccount = rule.transferToAccount
        }

        context.insert(transaction)

        // Update the payee record to keep autocomplete current
        updatePayeeRecord(name: rule.payee, category: rule.category, context: context)
    }

    /// Updates the Payee record for autocomplete, matching the pattern used in AddTransactionView.
    @MainActor
    private static func updatePayeeRecord(
        name: String,
        category: Category?,
        context: ModelContext
    ) {
        let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty, trimmed != "Transfer" else { return }

        let descriptor = FetchDescriptor<Payee>(predicate: #Predicate { $0.name == trimmed })
        if let existing = try? context.fetch(descriptor).first {
            existing.recordUsage(category: category)
        } else {
            let newPayee = Payee(name: trimmed, lastUsedCategory: category)
            context.insert(newPayee)
        }
    }
}

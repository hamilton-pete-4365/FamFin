import Foundation
import SwiftData
import Testing
@testable import FamFin

// MARK: - RecurrenceEngine Tests

@Suite("RecurrenceEngine processing")
struct RecurrenceEngineTests {

    /// Helper to create a recurring transaction due in the past
    @MainActor
    private func makeRecurring(
        in context: ModelContext,
        payee: String = "Netflix",
        amount: Decimal = 15,
        type: TransactionType = .expense,
        frequency: RecurrenceFrequency = .monthly,
        startDate: Date,
        endDate: Date? = nil,
        account: Account? = nil,
        category: BudgetCategory? = nil
    ) -> RecurringTransaction {
        let recurring = RecurringTransaction(
            amount: amount,
            payee: payee,
            type: type,
            frequency: frequency,
            startDate: startDate,
            endDate: endDate
        )
        recurring.account = account
        recurring.category = category
        context.insert(recurring)
        return recurring
    }

    @MainActor @Test("Creates transaction for a single due occurrence")
    func createsSingleTransaction() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        let account = Account(name: "Current", type: .current)
        context.insert(account)

        // Start date is yesterday
        let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: Date())!
        let recurring = makeRecurring(
            in: context,
            startDate: yesterday,
            account: account
        )
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        // Should have created one transaction
        let descriptor = FetchDescriptor<Transaction>()
        let transactions = try context.fetch(descriptor)
        #expect(transactions.count == 1)
        #expect(transactions.first?.payee == "Netflix")
        #expect(transactions.first?.amount == 15)
        #expect(transactions.first?.isAutoGenerated == true)
        #expect(transactions.first?.account?.name == "Current")

        // nextOccurrence should have advanced
        let calendar = Calendar.current
        let next = calendar.startOfDay(for: recurring.nextOccurrence)
        let today = calendar.startOfDay(for: Date())
        #expect(next > today)
    }

    @MainActor @Test("Creates multiple transactions for multiple missed occurrences")
    func createsMultipleForMissedDates() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        let account = Account(name: "Current", type: .current)
        context.insert(account)

        // Start date 3 weeks ago with weekly frequency
        let threeWeeksAgo = Calendar.current.date(byAdding: .weekOfYear, value: -3, to: Date())!
        _ = makeRecurring(
            in: context,
            frequency: .weekly,
            startDate: threeWeeksAgo,
            account: account
        )
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        let descriptor = FetchDescriptor<Transaction>()
        let transactions = try context.fetch(descriptor)
        // Should have created 3 or 4 transactions depending on exact timing
        #expect(transactions.count >= 3)
    }

    @MainActor @Test("Skips future occurrences")
    func skipsFutureOccurrences() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        // Start date is tomorrow
        let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: Date())!
        _ = makeRecurring(in: context, startDate: tomorrow)
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        let descriptor = FetchDescriptor<Transaction>()
        let transactions = try context.fetch(descriptor)
        #expect(transactions.isEmpty)
    }

    @MainActor @Test("Deactivates recurring transaction when end date is reached")
    func deactivatesAtEndDate() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        let account = Account(name: "Current", type: .current)
        context.insert(account)

        // Start 2 months ago, end 1 month ago, monthly frequency
        let twoMonthsAgo = Calendar.current.date(byAdding: .month, value: -2, to: Date())!
        let oneMonthAgo = Calendar.current.date(byAdding: .month, value: -1, to: Date())!

        let recurring = makeRecurring(
            in: context,
            frequency: .monthly,
            startDate: twoMonthsAgo,
            endDate: oneMonthAgo,
            account: account
        )
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        #expect(recurring.isActive == false)
    }

    @MainActor @Test("Skips inactive recurring transactions")
    func skipsInactive() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: Date())!
        let recurring = makeRecurring(in: context, startDate: yesterday)
        recurring.isActive = false
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        let descriptor = FetchDescriptor<Transaction>()
        let transactions = try context.fetch(descriptor)
        #expect(transactions.isEmpty)
    }

    @MainActor @Test("Links category to created transaction")
    func linksCategoryToTransaction() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        let account = Account(name: "Current", type: .current)
        let category = BudgetCategory(name: "Subscriptions", emoji: "ðŸ“º")
        context.insert(account)
        context.insert(category)

        let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: Date())!
        _ = makeRecurring(
            in: context,
            startDate: yesterday,
            account: account,
            category: category
        )
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        let descriptor = FetchDescriptor<Transaction>()
        let transactions = try context.fetch(descriptor)
        #expect(transactions.first?.category?.name == "Subscriptions")
    }

    @MainActor @Test("Transfer type links destination account")
    func transferLinksDestination() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        let from = Account(name: "Current", type: .current, isBudget: true)
        let to = Account(name: "Savings", type: .savings, isBudget: true)
        context.insert(from)
        context.insert(to)

        let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: Date())!
        let recurring = makeRecurring(
            in: context,
            payee: "Transfer",
            type: .transfer,
            startDate: yesterday,
            account: from
        )
        recurring.transferToAccount = to
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        let descriptor = FetchDescriptor<Transaction>()
        let transactions = try context.fetch(descriptor)
        #expect(transactions.first?.type == .transfer)
        #expect(transactions.first?.transferToAccount?.name == "Savings")
    }

    @MainActor @Test("Updates payee record after creating transaction")
    func updatesPayeeRecord() throws {
        let container = try makeTestContainer()
        let context = container.mainContext

        let account = Account(name: "Current", type: .current)
        context.insert(account)

        let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: Date())!
        _ = makeRecurring(
            in: context,
            payee: "Spotify",
            startDate: yesterday,
            account: account
        )
        try context.save()

        RecurrenceEngine.processRecurringTransactions(context: context)

        let payeeDescriptor = FetchDescriptor<Payee>()
        let payees = try context.fetch(payeeDescriptor)
        #expect(payees.contains { $0.name == "Spotify" })
    }
}
